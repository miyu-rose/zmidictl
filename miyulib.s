;========================================================================================
;
;  miyulib version 1.13 by はう (Hau) ＆ みゆ (miyu rose)
;
;                 Programmer  みゆ (miyu rose)
;                             X68KBBS：X68K0001
;                             X(Twitter)：@arith_rose
;
;            Special Adviser  はう (Hau) さま
;                     Tester  X68KBBS：X68K0024
;                             X(Twitter)：@Hau_oli
;
;========================================================================================

    .include    doscall.mac

    .cpu    68000

;========================================================================================

    .text
    .even

;========================================================================================
;
    mlib_vsyncwait::                            ; 垂直同期待ち
;
;----------------------------------------------------------------------------------------

@@:
    btst.b  #4,$00E88001                        ; V-DISP(MFP GPIP の bit4) が
    beq     @b                                  ; 0 (垂直帰線期間) ならループ
@@:
    btst.b  #4,$00E88001                        ; V-DISP(MFP GPIP の bit4) が
    bne     @b                                  ; 1 (垂直表示期間) ならループ

    rts

;========================================================================================
;
    mlib_printtitle::                              ; タイトル表記
;
;   arg     mlib_title                          ; タイトル文字列（のアドレス）
;           mlib_version                        ; バージョン文字列（のアドレス）
;           mlib_by                             ; by文字列（のアドレス）
;           mlib_author                         ; 作者文字列（のアドレス）
;
;----------------------------------------------------------------------------------------

    movem.l d0/a0,-(sp)                         ; d0, a0 を退避

    move.w  #$0006,d0                           ; $6 = $2(黄色) + $4(太字)
    lea.l   mlib_title,a0                       ; タイトルを
    bsr     mlib_cprint                         ;  表示するよ

    move.w  #$0007,d0                           ; $7 = $3(白)   + $4(太字)
    lea.l   mlib_version,a0                     ; バージョンを
    bsr     mlib_cprint                         ;  表示するよ

    move.w  #$0003,d0                           ; $3(白)
    lea.l   mlib_by,a0                          ; 'by' を
    bsr     mlib_cprint                         ;  表示するよ

    move.w  #$0003,d0                           ; $3(白)
    lea.l   mlib_author,a0                      ; 作者名を
    bsr     mlib_cprint                         ;  表示するよ

    move.w  #$0003,d0                           ; $3(白)
    lea.l   mlib_crlf,a0                        ; 改行を
    bsr     mlib_cprint                         ;  表示するよ

    movem.l (sp)+,d0/a0                         ; d0, a0 を復元
    rts

;========================================================================================
;
    mlib_cprint::                               ; 文字属性指定付き _PRINT
;
;   arg     d0.w                                ; 文字属性
;           a0.l                                ; 文字列のポインタ
;
;----------------------------------------------------------------------------------------

    move.w  d0,-(sp)                            ; 文字属性
    move.w  #$0002,-(sp)                        ; 文字属性の設定ﾓｰﾄﾞ
    DOS     _CONCTRL                            ;  に設定するよ
    addq.l  #4,sp

    pea.l   (a0)                                ; 文字列を
    DOS     _PRINT                              ;  表示するよ
    addq.l  #4,sp

    rts

;========================================================================================
;
    mlib_printdec::                             ; 32bit非負整数を十進文字列で表示
;
;   arg        d0.l                             ; 十進文字列表示したい32bit非負整数
;
;----------------------------------------------------------------------------------------

    movem.l d1/a5,-(sp)                         ; d1,a5 を退避

    link    a6,#-12                             ; a6 を push して a6=sp、sp-=12 する
    movea.l a6,a5                               ; a6 はとっとかないとなので a5 にコピー

    clr.b   -(a5)                               ; a5 を sp 代わりにして 0 を push
@@:
    bsr     mlib_div10                          ; d0 を 10 で割って、商を d0 / 余りを d1 へ
    ori.b   #$30,d1                             ; 余りを数字(文字)化
    move.b  d1,-(a5)                            ; a5 を sp 代わりにして余りを push
 
    cmp.l   #0,d0                               ; 商が
    bne     @b                                  ;  0 じゃなければループ

    move.l  a5,-(sp)                            ; 十進文字列(a5 に先頭アドレスが入ってます)を
    DOS     _PRINT                              ;  表示するよ

    unlk    a6                                  ; sp = a6 して pop した値を a6 へ復元

    movem.l (sp)+,d1/a5                         ; d1,a5 を復元
    rts

;========================================================================================
;
    mlib_printfloat::                           ; 小数点付き32bit非負整数を十進文字列で表示
;
;   arg     d0.l                                ; 十進文字列表示したい32bit非負整数
;           d1.l                                ; 小数点位置
;
;----------------------------------------------------------------------------------------

    movem.l d2/a5,-(sp)                         ; d2,a5 を退避
    link    a6,#-14                             ; a6 を push して a6=sp、sp-=14 する
    movea.l a6,a5                               ; a6 はとっとかないとなので a5 にコピー

    clr.b   -(a5)                               ; a5 を sp 代わりにして 0 を push
    move.l  d1,d2                               ; 小数点位置を d2 へ
@@:
    bsr     mlib_div10                          ; d0 を 10 で割って、商を d0 / 余りを d1 へ
    ori.b   #$30,d1                             ; 余りを数字(文字)化
    move.b  d1,-(a5)                            ; a5 を sp 代わりにして余りを push

    subq.l  #1,d2                               ; 小数点位置をデクリメント
    bne     @f                                  ; まだ小数点位置じゃなければスキップ
    move.b  #'.',-(a5)                          ; 小数点位置なので '.' を表示
@@:
    cmp.l   #0,d0                               ; 商が
    bne     @@b                                 ;  0 じゃなければループ

@@:
    btst.l  #31,d2                              ; 符号チェック
    bne     @@@f                                ; 負の数ならば小数点済みなのでおしまい

    tst.l   d2                                  ; 小数点位置が
    bne     @f                                  ; 0 じゃないのでスキップ

    move.w  #'0',-(sp)                          ; '0' を
    DOS     _PUTCHAR                            ;  表示するよ
    addq.l  #2,sp

    bra     @@@f                                ; おしまい
@@:
    move.w  #'0',-(sp)                          ; '0' を
    DOS     _PUTCHAR                            ;  表示するよ
    addq.l  #2,sp

    move.w  #'.',-(sp)                          ; '.' を
    DOS     _PUTCHAR                            ;  表示するよ
    addq.l  #2,sp

    subq.l  #1,d2                               ; 小数点位置をそのままループカウンタとします
@@:
    move.w  #'0',-(sp)                          ; '0' を
    DOS     _PUTCHAR                            ;  表示するよ
    addq.l  #2,sp

    dbra    d2,@b                               ; デクリメントループ
@@:
    move.l  a5,-(sp)                            ; 十進文字列(a5 に先頭アドレスが入ってます)を
    DOS     _PRINT                              ;  表示するよ

    unlk    a6                                  ; sp = a6 して pop した値を a6 へ復元
    movem.l (sp)+,d2/a5                         ; d2,a5 を復元
    rts

;========================================================================================
;
    mlib_printhex::                             ; 32bit非負整数を十六進文字列で表示
;
;   arg     d0.l                                ; 十六進文字列表示したい32bit非負整数
;
;----------------------------------------------------------------------------------------

    movem.l d0-d2,-(sp)                         ; d1,d2 を退避
 
    move.l  d0,d1                               ; 引数 d0 を d1 にコピー
    moveq.l #8-1,d2                             ; カウンタ
@@:
    rol.l   #4,d1                               ; d1 の上位4bitを下位4bitへローテーション
    move.l  d1,d0                               ; d0 に戻して
    bsr     mlib_puthex                         ;  表示する
    dbra    d2,@b                               ; d2 をデクリメントして 0 以上ならループ

    movem.l (sp)+,d0-d2                         ; d1,d2 を復元
    rts

;========================================================================================
;
    mlib_puthex::                               ; 4bit非負整数を十六進文字で表示
;
;   arg     d0.b                                ; 十六進文字表示したい4bit(上位4bitは無視)
;   return  d0.w                                ; 変換された十六進文字(上位1Byteは$00)
;
;----------------------------------------------------------------------------------------

    andi.w  #$000F,d0                           ; 下位4bitのみ抽出($00〜$0F)
    ori.b   #$30,d0                             ; '0'($30)〜'?'($3F) に変換
    cmpi.b  #'9',d0                             ; '9'($39)と比較して
    ble     @f                                  ;  以下('0'〜'9')なら次へ
    addq.b  #7,d0                               ; 大きい($39〜$3F)なら'A'($41)〜'F'($46)に変換
@@:
    move.w  d0,-(sp)                            ; 変換された十六進文字を
    DOS     _PUTCHAR                            ;  表示するよ
    addq.l  #2,sp

    rts

;========================================================================================
;
    mlib_getval::                               ; 十六進文字を数値化
;
;   arg     d0.b                                ; 数値化したい十六進文字
;   return  d0.b                                ; 数値化された値(最上位bitが1ならエラー)
;
;----------------------------------------------------------------------------------------

    tst.b   d0                                  ; $0
    beq     98f                                 ;  ならエラー

    bset.l  #5,d0                               ; 小文字化

    cmp.b   #'0',d0                             ; '0'
    blt     98f                                 ;  未満ならエラー
    cmp.b   #'9',d0                             ; '9' 
    ble     @f                                  ;  以下なら次へ
    cmp.b   #'a',d0                             ; 'a'
    blt     98f                                 ;  未満ならエラー
    cmp.b   #'f',d0                             ; 'f' 
    bgt     98f                                 ;  より大きければエラー

    sub.b   #'a'-10,d0                          ; 'a'-10 を引く
    bra     99f
@@:
    sub.b   #'0',d0                             ; '0' を引く
    bra     99f

98:
    st.b    d0                                  ; エラー
99:
    rts

;========================================================================================
;
    mlib_div10::                                ; 10 で割った商と余りを算出
;
;   arg     d0.l                                ; 元の非負整数(unsigned)
;   return  d0.l                                ; 商 = floor(元の非負整数/10)
;           d1.l                                ; 剰余 = n - 商*10
;
;----------------------------------------------------------------------------------------

    move.l  d2,-(sp)                            ; d2 を退避

    move.l  d0,d1                               ; n:  d1
    clr.l   d0                                  ; a:  d0
    move.l  #$A0000000,d2                       ; d: div

@@:
    lsl.l   #1,d0                               ; a *= 2

    cmp.l   d2,d1                               ; div を n と比較
    bcs     @f                                  ; div > n なら次へ

    sub.l   d2,d1                               ; n -= div
    addq.l  #1,d0                               ; a += 1

@@:
    lsr.l   #1,d2                               ; div >> 1
    btst.l  #0,d2                               ; div の LSBが
    beq     @@b                                 ;  0 ならループ

    move.l  (sp)+,d2                            ; d2 を復元
    rts

;========================================================================================

    .data
    .even

;----------------------------------------------------------------------------------------

mlib_crlf2::
    .dc.b   $0D,$0A
mlib_crlf::
    .dc.b   $0D,$0A
mlib_nul::
    .dc.b   $00

;========================================================================================
